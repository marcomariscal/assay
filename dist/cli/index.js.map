{"version":3,"sources":["../../src/cli/index.ts"],"sourcesContent":["#!/usr/bin/env node\n/**\n * rugscan CLI\n */\n\nimport { program } from \"commander\";\nimport { analyzeContract, formatAnalysis } from \"../core/analyzer.js\";\nimport type { Chain } from \"../core/types.js\";\n\nconst VALID_CHAINS: Chain[] = [\n\t\"ethereum\",\n\t\"base\",\n\t\"arbitrum\",\n\t\"optimism\",\n\t\"polygon\",\n];\n\nprogram\n\t.name(\"rugscan\")\n\t.description(\"Pre-transaction security analysis for EVM\")\n\t.version(\"0.1.0\");\n\nprogram\n\t.command(\"analyze\")\n\t.description(\"Analyze a contract for risk factors\")\n\t.argument(\"<address>\", \"Contract address to analyze\")\n\t.option(\"-c, --chain <chain>\", \"Chain to analyze on\", \"ethereum\")\n\t.option(\"--json\", \"Output as JSON\")\n\t.action(async (address: string, options: { chain: string; json?: boolean }) => {\n\t\tconst chain = options.chain.toLowerCase() as Chain;\n\n\t\tif (!VALID_CHAINS.includes(chain)) {\n\t\t\tconsole.error(\n\t\t\t\t`Invalid chain: ${chain}. Valid options: ${VALID_CHAINS.join(\", \")}`,\n\t\t\t);\n\t\t\tprocess.exit(1);\n\t\t}\n\n\t\tif (!/^0x[a-fA-F0-9]{40}$/.test(address)) {\n\t\t\tconsole.error(\"Invalid address format\");\n\t\t\tprocess.exit(1);\n\t\t}\n\n\t\tconsole.log(`Analyzing ${address} on ${chain}...\\n`);\n\n\t\ttry {\n\t\t\tconst analysis = await analyzeContract(address, { chain });\n\n\t\t\tif (options.json) {\n\t\t\t\tconsole.log(JSON.stringify(analysis, null, 2));\n\t\t\t} else {\n\t\t\t\tconsole.log(formatAnalysis(analysis));\n\t\t\t}\n\n\t\t\t// Exit with non-zero for high/critical risk\n\t\t\tif (analysis.riskLevel === \"high\" || analysis.riskLevel === \"critical\") {\n\t\t\t\tprocess.exit(1);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Analysis failed:\", error);\n\t\t\tprocess.exit(1);\n\t\t}\n\t});\n\nprogram\n\t.command(\"check\")\n\t.description(\"Quick check if a contract is verified\")\n\t.argument(\"<address>\", \"Contract address\")\n\t.option(\"-c, --chain <chain>\", \"Chain\", \"ethereum\")\n\t.action(async (address: string, options: { chain: string }) => {\n\t\tconst chain = options.chain.toLowerCase() as Chain;\n\n\t\ttry {\n\t\t\tconst analysis = await analyzeContract(address, { chain });\n\t\t\tconst icon = analysis.verified ? \"✅\" : \"❌\";\n\t\t\tconsole.log(\n\t\t\t\t`${icon} ${address} is ${analysis.verified ? \"verified\" : \"NOT verified\"} on ${chain}`,\n\t\t\t);\n\t\t\tprocess.exit(analysis.verified ? 0 : 1);\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Check failed:\", error);\n\t\t\tprocess.exit(1);\n\t\t}\n\t});\n\nprogram.parse();\n"],"mappings":";;;;;;;AAKA,SAAS,eAAe;AAIxB,IAAM,eAAwB;AAAA,EAC7B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACD;AAEA,QACE,KAAK,SAAS,EACd,YAAY,2CAA2C,EACvD,QAAQ,OAAO;AAEjB,QACE,QAAQ,SAAS,EACjB,YAAY,qCAAqC,EACjD,SAAS,aAAa,6BAA6B,EACnD,OAAO,uBAAuB,uBAAuB,UAAU,EAC/D,OAAO,UAAU,gBAAgB,EACjC,OAAO,OAAO,SAAiB,YAA+C;AAC9E,QAAM,QAAQ,QAAQ,MAAM,YAAY;AAExC,MAAI,CAAC,aAAa,SAAS,KAAK,GAAG;AAClC,YAAQ;AAAA,MACP,kBAAkB,KAAK,oBAAoB,aAAa,KAAK,IAAI,CAAC;AAAA,IACnE;AACA,YAAQ,KAAK,CAAC;AAAA,EACf;AAEA,MAAI,CAAC,sBAAsB,KAAK,OAAO,GAAG;AACzC,YAAQ,MAAM,wBAAwB;AACtC,YAAQ,KAAK,CAAC;AAAA,EACf;AAEA,UAAQ,IAAI,aAAa,OAAO,OAAO,KAAK;AAAA,CAAO;AAEnD,MAAI;AACH,UAAM,WAAW,MAAM,gBAAgB,SAAS,EAAE,MAAM,CAAC;AAEzD,QAAI,QAAQ,MAAM;AACjB,cAAQ,IAAI,KAAK,UAAU,UAAU,MAAM,CAAC,CAAC;AAAA,IAC9C,OAAO;AACN,cAAQ,IAAI,eAAe,QAAQ,CAAC;AAAA,IACrC;AAGA,QAAI,SAAS,cAAc,UAAU,SAAS,cAAc,YAAY;AACvE,cAAQ,KAAK,CAAC;AAAA,IACf;AAAA,EACD,SAAS,OAAO;AACf,YAAQ,MAAM,oBAAoB,KAAK;AACvC,YAAQ,KAAK,CAAC;AAAA,EACf;AACD,CAAC;AAEF,QACE,QAAQ,OAAO,EACf,YAAY,uCAAuC,EACnD,SAAS,aAAa,kBAAkB,EACxC,OAAO,uBAAuB,SAAS,UAAU,EACjD,OAAO,OAAO,SAAiB,YAA+B;AAC9D,QAAM,QAAQ,QAAQ,MAAM,YAAY;AAExC,MAAI;AACH,UAAM,WAAW,MAAM,gBAAgB,SAAS,EAAE,MAAM,CAAC;AACzD,UAAM,OAAO,SAAS,WAAW,WAAM;AACvC,YAAQ;AAAA,MACP,GAAG,IAAI,IAAI,OAAO,OAAO,SAAS,WAAW,aAAa,cAAc,OAAO,KAAK;AAAA,IACrF;AACA,YAAQ,KAAK,SAAS,WAAW,IAAI,CAAC;AAAA,EACvC,SAAS,OAAO;AACf,YAAQ,MAAM,iBAAiB,KAAK;AACpC,YAAQ,KAAK,CAAC;AAAA,EACf;AACD,CAAC;AAEF,QAAQ,MAAM;","names":[]}